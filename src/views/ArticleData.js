


let articleArr=[
				{
					year:2016,
					monthes:[{
						month:6,
						days:[{
							day:20,
							tit:'Thinking in React',
							con:[
								'# Thinking in React\n',
								'## 开始一个栗子\n*****\n',
								'我们要做的是这样一个例子\n',
								'<img src="./dist/img/thinking-in-react-mock.png" />\n',
								'后台返回的数据应该是这样的:\n',
								'```js\n[\n	{category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},\n',
								'	{category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},\n',
								'	{category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},\n',
								'	{category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},\n',
								'	{category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},\n',
								'	{category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}\n];\n```\n',
								'## 第一步：把视图拆分成一个个组件\n\n',
								'怎么样拆分组件呢？原则只有一个，就是每一个组件应该只做一件事，如果当前组件做了很多事，应该继续分解这个组件\n',
								'因为最终用户所看到的界面和我们的数据模型往往有着一样的信息结构，我们只需要根据数据的结构来分解我们的组件\n',
								'<img src="./dist/img/thinking-in-react-components.png" />\n',
								'可以看到最终我们把这个简单的页面分解成5个不同的组件，让我们来分析一下这五个组件的各自功能\n',
								'1. 1.FilterableProductTable (orange): 最外层的组件\n',
								'2. 2.SearchBar (blue): 接受用户输入的组件\n',
								'3. 3.ProductTable (green): 展示用户搜索到的所有数据\n',
								'4. 4.ProductCategoryRow (turquoise): 展示商品的类别\n',
								'5. 5.ProductRow (red): 展示每个商品的相关信息\n\n',
								'如果你仔细观察	ProductTable\n组件，会发现有个表格的标题不属于这个组件，这是个人喜好问题，在这里我把\n',
								'它放在ProductTable组件里因为它是渲染数据集合的一部分，而ProductTable就是用来渲染数据的\n',
								'但是，如果header部分后期有其他字段添加进来而变得复杂，就需要把它拆分为一个独立的ProductTableHeader组件\n',
								'现在我们已经划分好组件了，让我们把他们整理成一个层次结构\n',
								'* 	`.FilterableProductTable`\n* &emsp;`.SearchBar`\n* &emsp;`.ProductTable`\n\n* &emsp;&emsp;`.ProductCategoryRow`\n* &emsp;&emsp;`.ProductRow`\n\n',
								'## 第二步 用React写一个静态版本\n\n',
								'```html\nvar ProductCategoryRow = React.createClass({\n',
								'  render: function() {\n',
								'    return (<tr><th colSpan="2">{this.props.category}</th></tr>);\n',
								'  }\n',
								'});\n',
								'var ProductRow = React.createClass({\n',
								'  render: function() {\n',
								'    var name = this.props.product.stocked ?\n',
								'      this.props.product.name :\n',
								'      <span style={{color: \'red\'}}>\n',
								'        {this.props.product.name}\n',
								'      </span>;\n',
								'    return (\n',
								'      <tr>\n',
								'        <td>{name}</td>\n',
								'        <td>{this.props.product.price}</td>\n',
								'      </tr>\n',
								'    );\n',
								'  }\n',
								'});\n',
								'var ProductTable = React.createClass({\n',
								'  render: function() {\n',
								'    var rows = [];\n',
								'    var lastCategory = null;\n',
								'    this.props.products.forEach(function(product) {\n',
								'      if (product.category !== lastCategory) {\n',
								'        rows.push(<ProductCategoryRow category={product.category} key={product.category} />);\n',
								'      }\n',
								'      rows.push(<ProductRow product={product} key={product.name} />);\n',
								'      lastCategory = product.category;\n',
								'    });\n',
								'    return (\n',
								'  <table>\n',
								'    <thead>\n',
								'      <tr>\n',
								'        <th>Name</th>\n',
								'        <th>Price</th>\n',
								'      </tr>\n',
								'	 </thead>\n',
								'    <tbody>{rows}</tbody>\n',
								'  </table>\n',
								'    );\n',
								'  }\n',
								'});\n',
								'var SearchBar = React.createClass({\n',
								'  render: function() {\n',
								'    return (\n',
								'      <form>\n',
								'        <input type="text" placeholder="Search..." />\n',
								'        <p>\n',
								'          <input type="checkbox" />\n',
								'          {\' \'}\n',
								'          Only show products in stock\n',
								'        </p>\n',
								'      </form>\n',
								'    );\n',
								'  }\n',
								'});\n',
								'var FilterableProductTable = React.createClass({\n',
								'  render: function() {\n',
								'    return (\n',
								'      <div>\n',
								'        <SearchBar />\n',
								'        <ProductTable products={this.props.products} />\n',
								'      </div>\n',
								'    );\n',
								'  }\n',
								'});\n',
								'var PRODUCTS = [\n',
								'  {category: \'Sporting Goods\', price: \'$49.99\', stocked: true, name: \'Football\'},\n',
								'  {category: \'Sporting Goods\', price: \'$9.99\', stocked: true, name: \'Baseball\'},\n',
								'  {category: \'Sporting Goods\', price: \'$29.99\', stocked: false, name: \'Basketball\'},\n',
								'  {category: \'Electronics\', price: \'$99.99\', stocked: true, name: \'iPod Touch\'},\n',
								'  {category: \'Electronics\', price: \'$399.99\', stocked: false, name: \'iPhone 5\'},\n',
								'  {category: \'Electronics\', price: \'$199.99\', stocked: true, name: \'Nexus 7\'}\n',
								'];\n',
								'ReactDOM.render(\n',
								'  <FilterableProductTable products={PRODUCTS} />,\n',
								'document.getElementById(\'container\')\n',
								');\n```\n\n',
								'现在我们已经写好了自己的组件结构，我们可以运行我们的程序了，但是目前我们的程序仅仅把数据渲染到页面上\n',
								'并没有实现交互功能，所有的数据都是通过props传入的，而props是不可变的，所以我们需要为我们的app添加一下交互功能\n',
								'当然，我们需要用到state来帮助我们实现交互\n\n',
								'## 第三步找出所有需要用到的state\n\n',
								'因为我们的程序是通过底层数据渲染的，所以要实现交互，就要让底层数据可以改变，state可以很简单的实现这个\n',
								'我们不应该将所有的数据都保存为state变量，只需要找出构建应用所需要的最少的state数据\n',
								'首先思考应用中的所有数据：\n',
								'* &emsp;最初的products列表\n* &emsp;用户的输入\n* &emsp;用户的勾选\n*  &emsp;过滤后的products列表\n\n',
								'在这些数据中只有用户的输入和勾选是会随着时间改变而且无法根据其他数据计算出来的，所以最终的state是：\n',
								'* &emsp;用户的输入\n* &emsp;用户的勾选\n\n',
								'## 第四步 确认state的生命周期\n\n',
								'我们已经找出了state集合，接下来需要知道哪个组件应该拥有这些state\n\n',
								'这里我们需要知道，react中数据是沿着组件树从上到下单向流动的\n\n',
								'对于每一个state：\n\n',
								'1. 找出每一个基于那个 state 渲染界面的组件。\n',
								'2. 找出共同的祖先组件（某个单个的组件，在组件树中位于需要这个 state 的所有组件的上面）。\n',
								'3. 要么是共同的祖先组件，要么是另外一个在组件树中位于更高层级的组件应该拥有这个 state 。\n',
								'4. 如果找不出拥有这个state 数据模型的合适的组件，创建一个新的组件来维护这个 state ，然后添加到组件树中，层级位于所有共同拥有者组件的上面。\n\n',
								'在我们这个程序中：\n\n',
								'* ProductTable 需要基于 state 过滤产品列表，SearchBar 需要显示搜索文本和复选框状态。\n',
								'* 共同拥有者组件是 FilterableProductTable 。\n',
								'* 理论上，过滤文本和复选框值位于 FilterableProductTable 中是合适的。\n\n',
								'所以只需要把我们的静态版本中对应部分进行更改\n\n',
								'```js\nvar FilterableProductTable = React.createClass({\n',
								'	  getInitialState: function() {\n',
								'	    return {\n',
								'	      filterText: \'\',',
								'	      inStockOnly: false\n',
								'	    };\n',
								'	  },\n',
								'	  render: function() {\n',
								'	    return (\n',
								'	      <div>\n',
								'	        <SearchBar\n',
								'	          filterText={this.state.filterText}\n',
								'	          inStockOnly={this.state.inStockOnly}\n',
								'	        />\n',
								'	        <ProductTable\n',
								'	          products={this.props.products}\n',
								'	          filterText={this.state.filterText}\n',
								'	          inStockOnly={this.state.inStockOnly}\n',
								'	        />\n',
								'	      </div>\n',
								'	    );\n',
								'	  }\n',
								'	});\n```\n\n',
								'然后是searchBar组件\n\n',
								'```js\nvar SearchBar = React.createClass({\n',
								'	  render: function() {\n',
								'	    return (\n ',
								'	      <form>\n',
								'	        <input type="text" placeholder="Search..." value={this.props.filterText} />\n',
								'	        <p>\n',
								'	          <input type="checkbox" checked={this.props.inStockOnly} />\n',
								'	          {\' \'}\n',
								'	          Only show products in stock\n',
								'	        </p>\n',
								'	      </form>\n',
								'	    );\n',
								'	  }\n',
								'	});\n```\n\n',
								'接着在ProductTable里面加上入户输入的过滤\n\n',
								'	if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked && this.props.inStockOnly)) {\n',
								'        return;\n',
								'      }\n\n',
								'注意，这里需要手动绑定this到当前组件\n',
								'## 第五步：添加反向数据流\n\n',
								'到目前为止，已经构建了渲染正确的基于 props 和 state 的沿着组件树从上至下单向数据流动的应用。现在，是时候支持另外一种数据流动方式了：组件树中层级很深的表单组件需要更新 FilterableProductTable 中的 state 。\n\n',
								'React 让这种数据流动非常明确，从而很容易理解应用是如何工作的，但是相对于传统的双向数据绑定，确实需要输入更多的东西。 React 提供了一个叫做 ReactLink 的插件来使其和双向数据绑定一样方便，但是考虑到这篇文章的目的，我们将会保持所有东西都直截了当。\n\n',
								'如果你尝试在示例的当前版本中输入或者选中复选框，将会发现 React 会忽略你的输入。这是有意的，因为已经设置了 input 的 value 属性，使其总是与从 FilterableProductTable 传递过来的 state 一致。',
								'让我们思考下我们希望发生什么。我们想确保无论何时用户改变了表单，都要更新 state 来反映用户的输入。由于组件只能更新自己的 state ， FilterableProductTable 将会传递一个回调函数给 SearchBar ，此函数将会在 state 应该被改变的时候触发。我们可以使用 input 的 onChange 事件来监听用户输入，从而确定何时触发回调函数。\n\n',
								'FilterableProductTable 传递的回调函数将会调用 setState() ，然后应用将会被更新。',
								'虽然这听起来有很多内容，但是实际上仅仅需要几行代码。并且关于数据在应用中如何流动真的非常清晰明确。\n\n',
								'首先在FilterableProductTable组件中写一个handleUserInput事件，并将事件传递给SearchBar组件中\n\n',
								'	handleUserInput: function(filterText, inStockOnly) {\n',
								'	    this.setState({\n',
								'	      filterText: filterText,\n',
								'	      inStockOnly: inStockOnly\n',
								'	    });\n',
								'	  }\n',
								'<SearchBar\n',
								'      filterText={this.state.filterText}\n',
								'      inStockOnly={this.state.inStockOnly}\n',
								'      onUserInput={this.handleUserInput}\n',
								'    />\n\n',
								'然后在SearchBar组件中调用这个事件来改变state\n\n',
								'```js\nhandleChange: function() {\n',
								'    this.props.onUserInput(\n',
								'      this.refs.filterTextInput.value,\n',
								'      this.refs.inStockOnlyInput.checked\n',
								'    );\n',
								'  }\n',
								'<input\n',
								'  type="text"\n',
								'  placeholder="Search..."\n',
								'  value={this.props.filterText}\n',
								'  ref="filterTextInput"\n',
								'  onChange={this.handleChange}\n',
								'/>\n```\n\n',
								'现在我们的程序就可以根据用户的操作来显示对应的数据了'
							].join('')
						},{
							day:19,
							tit:'React单向数据流',
							con:[
								'# React单向数据流\n',
								'一个大神的回答：\n',
								'>只要给的数据是一定的，生成的东西就是一定的，称之为pure rendering comp或者stateless comp',
								'react的单向数据流就是这个意思，只有最顶层的组件有state，其他地方都按照那个state的数据通过props传过去',
								'这样只要state一致。整个树的样子就是固定的，于是调试，整理逻辑什么的非常清晰，数据都从顶层的state',
								'通过props传递到下面的pure rendering的组件\n\n',
								'一个歪果仁的回答：\n',
								'>In short: in React, data flows in one direction: action -> store (state) -> view controller -> dispatch an action.',
								' As you noted, this makes your program a lot easier to reason about.',
								'If you want to create a form that updates state when you update the form,',
								'you\'d have to use onChange on the element and dispatch a function.',
								'Two-way binding on the other hand directly links state to the element, so that if one changes, the other immediately changes as well.',
								'This seems very elegant as well but it turns out that it\'s not performant at scale and data going in two directions in',
								'and out of your components makes things harder to understand and reason about.',
								'ReactLink can be used (cautiously) if you need two-way binding.\n\n',
								'我的理解：\n\n',
								'>在我看来，React单向数据流的意思就是数据都来自最顶层的组件，然后通过props传递到需要用到的子组件上,当子组件需要改变state的时候',
								'现在顶层组件定义对应的handleChange事件并且传递给子组件，然后子组件调用handleChange事件，将新的state以参数的形式传递给顶层组件,',
								'然后在顶层组件完成setState完成数据的重新渲染。子组件需要做的只是将新的state传给顶层组件，剩下的就不用管了，这样所有的数据都是从',
								'顶层组件传递下去的，这样数据的来源就很清晰，出现错误什么的也很方便定位。'
							].join('')
						},{
							day:18,
							tit:'React 相关网站',
							con:[
								'# React 相关网站\n\n*****\n\n',
								'>React官网：[React](http://facebook.github.io/react/)  \n中文版：[React](http://reactjs.cn/react/index.html)\n\n',
								'>React-Router文档：[React-Router](https://github.com/reactjs/react-router) \n 中文版：[React-Router](http://react-guide.github.io/react-router-cn/index.html)\n\n',
								'>Redux文档：[Redux](http://redux.js.org/)  \n中文版：[Redux](http://cn.redux.js.org/)\n\n',
								'>React中文社区：[React中文社区](http://react-china.org/)\n\n',
								'>Webpack文档：[Webpack](http://webpack.github.io/docs/)  \n中文指南：[Webpack](http://webpackdoc.com/)\n\n',
								'>React Webpack 小书：[React Webpack 小书](https://fakefish.github.io/react-webpack-cookbook/)\n\n',
								'>survivejs官网：[survivejs](http://survivejs.com/)\n\n',
								'>js插件：[js插件](https://js.coach/)\n\n'

							].join('')
						},{
							day:17,
							tit:'Markdown Demo',
							con:[
								'# Markdown demo\n\nChanges are automatically rendered as you type.\n\n* Follows the ',
				                '[CommonMark](http://commonmark.org/) spec\n* Renders actual, "native" React DOM ',
				                'elements\n* Allows you to escape or skip HTML (try toggling the checkboxes above)',
				                '\n* If you escape or skip the HTML, no `dangerouslySetInnerHTML` is used! Yay!\n',
				                '\n## HTML block below\n\n<blockquote>\n    This blockquote will change based ',
				                'on the HTML settings above.\n</blockquote>\n\n## How about some code?\n',
				                '```js\nvar React = require(\'react\');\nvar Markdown = require(\'react-markdown\');',
				                '\n\nReact.render(\n    <Markdown source="# Your markdown here" />,\n    document.',
				                'getElementById(\'content\')\n);\n```\n\nPretty neat, eh?\n\n', '## More info?\n\n',
				                'Read usage information and more on [GitHub](//github.com/rexxars/react-markdown)\n\n',
				                '---------------\n\n',
				                'A component by [VaffelNinja](http://vaffel.ninja) / Espen Hovlandsdal'
							].join('')
						},{
							day:16,
							tit:'一名前端攻城狮',
							con:[
								'# 一名前端攻城狮\n\n',
								'## 序\n\n*****\n\n前前后后花了大概1个月的时间总算是把人生中第一个个人博客完成了，从一开始的充满兴趣',
								'到现在写完自己的第一篇博客，这其中有过兴奋，有过激动，也有过失落，有过疲倦，不论如何，',
								'自己总算是坚持下来了，目前的技术还很low，不会服务器及数据库相关知识，只能手写数据，',
								'所以这只是一个简单的静态博客，虽然是这样，也收获了很多：第一次用React写代码，第一次写',
								'webpack的配置文件并运用到项目中，第一次尝试用es6写js逻辑，第一次使用postcss来写css',
								'(一开始打算用less，用npm安装autoprefixer的时候，命令行里推荐使用postcss，当时还不知道这是个什么鬼，就去百度了一下，觉得很高大上，就用postcss了，虽然我',
								'并没有用它来做什么高大上的东西/(ㄒoㄒ)/~~)，并且了解了markdown和highlight相关应用...\n\n',
								'感谢一直认真学习并且监督我学习的大哥和小丁，让我没有机会偷懒.\n\n',
								'谢谢所有来我博客的你们，有什么好的建议或者想法欢迎联系我.\n\n',
								'## 联系我\n\n*****\n\n',
								'1. Email:417300459@qq.com\n\n2. qq:417300459\n\n3. github:[fightingm](https://github.com/fightingm)'
							].join('')
						}]
					}]
				}
			];

export default articleArr;